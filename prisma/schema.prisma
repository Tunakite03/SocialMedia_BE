// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum PostType {
  TEXT
  IMAGE
  VIDEO
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  VOICE
}

enum ConversationType {
  DIRECT
  GROUP
}

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
  MESSAGE
  CALL
  MENTION
}

enum CallType {
  VOICE
  VIDEO
}

enum CallStatus {
  PENDING
  ONGOING
  ENDED
  MISSED
}

enum ReactionType {
  LIKE
  LOVE
  LAUGH
  ANGRY
  SAD
  WOW
}

enum SentimentType {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

model User {
  id               String    @id @default(uuid())
  email            String    @unique
  username         String    @unique
  password         String
  displayName      String
  avatar           String?
  bio              String?
  dateOfBirth      DateTime?
  role             UserRole  @default(USER)
  isActive         Boolean   @default(true)
  isOnline         Boolean   @default(false)
  lastSeen         DateTime?
  emailVerified    Boolean   @default(false)
  resetToken       String?   @unique
  resetTokenExpiry DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  posts             Post[]
  comments          Comment[]
  reactions         Reaction[]
  sentMessages      Message[]                 @relation("SentMessages")
  receivedMessages  Message[]                 @relation("ReceivedMessages")
  conversations     ConversationParticipant[]
  notifications     Notification[]            @relation("NotificationReceiver")
  sentNotifications Notification[]            @relation("NotificationSender")
  initiatedCalls    Call[]                    @relation("CallInitiator")
  receivedCalls     Call[]                    @relation("CallReceiver")
  followers         Follow[]                  @relation("UserFollowers")
  following         Follow[]                  @relation("UserFollowing")
  sentimentAnalyses SentimentAnalysis[]
  sessions          Session[]

  @@map("users")
}

model Session {
  id           String   @id @default(uuid())
  userId       String
  refreshToken String   @unique
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
  @@index([refreshToken])
  @@index([expiresAt])
  @@map("sessions")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@map("follows")
}

model Post {
  id        String   @id @default(uuid())
  content   String
  type      PostType @default(TEXT)
  mediaUrl  String?
  isPublic  Boolean  @default(true)
  authorId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author    User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments  Comment[]
  reactions Reaction[]

  // Indexes for performance optimization
  @@index([isPublic, createdAt(sort: Desc)]) // For feed pagination
  @@index([type, isPublic, createdAt(sort: Desc)]) // For filtered feed
  @@index([authorId, createdAt(sort: Desc)]) // For user posts
  @@map("posts")
}

model Comment {
  id        String   @id @default(uuid())
  content   String
  postId    String
  authorId  String
  parentId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  post      Post       @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent    Comment?   @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]  @relation("CommentReplies")
  reactions Reaction[]

  @@map("comments")
}

model Reaction {
  id        String       @id @default(uuid())
  type      ReactionType
  userId    String
  postId    String?
  commentId String?
  createdAt DateTime     @default(now())

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post    Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@unique([userId, commentId])
  @@map("reactions")
}

model Conversation {
  id        String           @id @default(uuid())
  name      String?
  type      ConversationType @default(DIRECT)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relations
  participants ConversationParticipant[]
  messages     Message[]

  @@map("conversations")
}

model ConversationParticipant {
  id             String    @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime  @default(now())
  leftAt         DateTime?

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Message {
  id             String      @id @default(uuid())
  content        String
  type           MessageType @default(TEXT)
  mediaUrl       String?
  conversationId String
  senderId       String
  receiverId     String?
  isRead         Boolean     @default(false)
  readAt         DateTime?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver     User?        @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Notification {
  id         String           @id @default(uuid())
  type       NotificationType
  title      String
  message    String
  isRead     Boolean          @default(false)
  receiverId String
  senderId   String?
  entityId   String?
  entityType String?
  createdAt  DateTime         @default(now())

  // Relations
  receiver User  @relation("NotificationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender   User? @relation("NotificationSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model Call {
  id         String     @id @default(uuid())
  type       CallType
  status     CallStatus @default(PENDING)
  duration   Int? // in seconds
  callerId   String
  receiverId String
  startedAt  DateTime?
  endedAt    DateTime?
  createdAt  DateTime   @default(now())

  // Relations
  caller   User @relation("CallInitiator", fields: [callerId], references: [id], onDelete: Cascade)
  receiver User @relation("CallReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@map("calls")
}

model SentimentAnalysis {
  id         String        @id @default(uuid())
  content    String
  sentiment  SentimentType
  confidence Float
  userId     String
  entityId   String // Can be postId, commentId, messageId
  entityType String // 'post', 'comment', 'message'
  createdAt  DateTime      @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sentiment_analyses")
}
